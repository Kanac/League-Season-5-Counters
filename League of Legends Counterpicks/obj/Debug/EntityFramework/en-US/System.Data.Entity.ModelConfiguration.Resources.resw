<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ConflictingConstraint" xml:space="preserve">
    <value>The navigation property '{0}' declared on type '{1}' has been configured with conflicting foreign keys.</value>
  </data>
  <data name="ValidationHeader" xml:space="preserve">
    <value>One or more validation errors were detected during model generation:</value>
  </data>
  <data name="UnableToDeterminePrincipal" xml:space="preserve">
    <value>Unable to determine the principal end of an association between the types '{0}' and '{1}'. The principal end of this association must be explicitly configured using either the relationship fluent API or data annotations.</value>
  </data>
  <data name="ConventionNotFound" xml:space="preserve">
    <value>Unable to add the convention '{0}'. Could not find an existing convention of type '{1}' in the current convention set.</value>
  </data>
  <data name="InvalidPropertiesExpression" xml:space="preserve">
    <value>The properties expression '{0}' is not valid. The expression should represent a property: C#: 't =&gt; t.MyProperty'  VB.Net: 'Function(t) t.MyProperty'. When specifying multiple properties use an anonymous type: C#: 't =&gt; new {{ t.MyProperty1, t.MyProperty2 }}'  VB.Net: 'Function(t) New From {{ t.MyProperty1, t.MyProperty2 }}'.</value>
  </data>
  <data name="IncorrectColumnCount" xml:space="preserve">
    <value>The specified association foreign key columns '{0}' are invalid. The number of columns specified must match the number of primary key columns.</value>
  </data>
  <data name="ForeignKeyAttributeConvention_OrderRequired" xml:space="preserve">
    <value>Unable to determine a composite foreign key ordering for foreign key on type {0}. When using the ForeignKey data annotation on composite foreign key properties ensure order is specified by using the Column data annotation or the fluent API.</value>
  </data>
  <data name="ConflictingConfigurationValue" xml:space="preserve">
    <value>{0} = {1} conflicts with {2} = {3}</value>
  </data>
  <data name="ForeignKeyAttributeConvention_InvalidKey" xml:space="preserve">
    <value>The ForeignKeyAttribute on property '{0}' on type '{1}' is not valid. The foreign key name '{2}' was not found on the dependent type '{3}'. The Name value should be a comma separated list of foreign key property names.</value>
  </data>
  <data name="ArgumentIsNullOrWhitespace" xml:space="preserve">
    <value>The argument '{0}' cannot be null, empty or contain only white space.</value>
  </data>
  <data name="ModelBuilder_KeyPropertiesMustBePrimitive" xml:space="preserve">
    <value>The property '{0}' cannot be used as a key property on the entity '{1}' because the property type is not a valid key type. Only scalar types, string and byte[] are supported key types.</value>
  </data>
  <data name="ConflictingMultiplicities" xml:space="preserve">
    <value>The navigation property '{0}' declared on type '{1}' has been configured with conflicting multiplicities.</value>
  </data>
  <data name="NavigationInverseItself" xml:space="preserve">
    <value>The navigation property '{0}' declared on type '{1}' cannot be the inverse of itself.</value>
  </data>
  <data name="ForeignKeyAttributeConvention_EmptyKey" xml:space="preserve">
    <value>The ForeignKeyAttribute on property '{0}' on type '{1}' is not valid. Name must not be empty.</value>
  </data>
  <data name="InvalidTableMapping_NoTableName" xml:space="preserve">
    <value>Map was called more than once for type '{0}' and at least one of the calls didn't specify the target table name.</value>
  </data>
  <data name="InvalidComplexPropertyExpression" xml:space="preserve">
    <value>The expression '{0}' is not a valid property expression. The expression should represent a property: C#: 't =&gt; t.MyProperty'  VB.Net: 'Function(t) t.MyProperty'. Use dotted paths for nested properties: C#: 't =&gt; t.MyProperty.MyProperty'  VB.Net: 'Function(t) t.MyProperty.MyProperty'.</value>
  </data>
  <data name="InvalidComplexType" xml:space="preserve">
    <value>The type '{0}' was not mapped. Check that the type has not been explicitly excluded by using the Ignore method or NotMappedAttribute data annotation. Verify that the type was defined as a class, is not primitive, nested or generic, and does not inherit from ComplexObject.</value>
  </data>
  <data name="ConflictingMapping" xml:space="preserve">
    <value>The navigation property '{0}' declared on type '{1}' has been configured with conflicting mapping information.</value>
  </data>
  <data name="InvalidDiscriminatorType" xml:space="preserve">
    <value>Values of type '{0}' cannot be used as type discriminator values. Supported types include byte, signed byte, bool, int16, int32, int64, and string.</value>
  </data>
  <data name="UnmappedAbstractType" xml:space="preserve">
    <value>The abstract type '{0}' has no mapped descendents and so cannot be mapped. Either remove '{0}' from the model or add one or more types deriving from '{0}' to the model. </value>
  </data>
  <data name="EntityTypeConfigurationMismatch" xml:space="preserve">
    <value>The type '{0}' has already been configured as a complex type. It cannot be reconfigured as an entity type.</value>
  </data>
  <data name="PropertyNotFound" xml:space="preserve">
    <value>The property '{0}' is not a declared property on type '{1}'. Verify that the property has not been explicitly excluded from the model by using the Ignore method or NotMappedAttribute data annotation. Make sure that it is a valid primitive property.</value>
  </data>
  <data name="ToTable_InvalidTableName" xml:space="preserve">
    <value>The qualified table name '{0}' contains an invalid table name. Table names must have a non-zero length.</value>
  </data>
  <data name="ConflictingCascadeDeleteOperation" xml:space="preserve">
    <value>The navigation property '{0}' declared on type '{1}' has been configured with conflicting cascade delete operations using 'WillCascadeOnDelete'.</value>
  </data>
  <data name="InvalidEntityType" xml:space="preserve">
    <value>The type '{0}' was not mapped. Check that the type has not been explicitly excluded by using the Ignore method or NotMappedAttribute data annotation. Verify that the type was defined as a class, is not primitive, nested or generic, and does not inherit from EntityObject.</value>
  </data>
  <data name="ValidationItemFormat" xml:space="preserve">
    <value>	{0}: {1}: {2}</value>
  </data>
  <data name="InversePropertyAttributeConvention_SelfInverseDetected" xml:space="preserve">
    <value>A relationship cannot be established from property '{0}' on type '{1}' to property '{0}' on type '{1}'. Check the values in the InversePropertyAttribute to ensure relationship definitions are unique and reference from one navigation property to its corresponding inverse navigation property.</value>
  </data>
  <data name="InvalidChainedMappingSyntax" xml:space="preserve">
    <value>The derived type '{0}' has already been mapped using the chaining syntax. A derived type can only be mapped once using the chaining syntax.</value>
  </data>
  <data name="DuplicateStructuralTypeConfiguration" xml:space="preserve">
    <value>A configuration for type '{0}' has already been added. To reference the existing configuration use the Entity&lt;T&gt;() or ComplexType&lt;T&gt;() methods.</value>
  </data>
  <data name="InvalidComplexPropertiesExpression" xml:space="preserve">
    <value>The properties expression '{0}' is not valid. The expression should represent a property: C#: 't =&gt; t.MyProperty'  VB.Net: 'Function(t) t.MyProperty'. When specifying multiple properties use an anonymous type: C#: 't =&gt; new {{ t.MyProperty1, t.MyProperty2 }}'  VB.Net: 'Function(t) New From {{ t.MyProperty1, t.MyProperty2 }}'.</value>
  </data>
  <data name="UnsupportedHybridInheritanceMapping" xml:space="preserve">
    <value>The type '{0}' cannot be mapped as defined because it maps inherited properties from types that use entity splitting or another form of inheritance. Either choose a different inheritance mapping strategy so as to not map inherited properties, or change all types in the hierarchy to map inherited properties and to not use splitting. </value>
  </data>
  <data name="EntityMappingConfiguration_DuplicateMappedProperty" xml:space="preserve">
    <value>Properties for type '{0}' can only be mapped once. The non-key property '{1}' is mapped more than once. Ensure the Properties method specifies each non-key property only once.</value>
  </data>
  <data name="InvalidNotNullCondition" xml:space="preserve">
    <value>An "is not null" condition cannot be specified on property '{0}' on type '{1}' because this property is not included in the model. Check that the property has not been explicitly excluded from the model by using the Ignore method or NotMappedAttribute data annotation.</value>
  </data>
  <data name="ConflictingPropertyConfiguration" xml:space="preserve">
    <value>Conflicting configuration settings were specified for property '{0}' on type '{1}': {2}</value>
  </data>
  <data name="CircularComplexTypeHierarchy" xml:space="preserve">
    <value>A circular ComplexType hierarchy was detected. Self-referencing ComplexTypes are not supported.</value>
  </data>
  <data name="ToTable_InvalidSchemaName" xml:space="preserve">
    <value>The qualified table name '{0}' contains an invalid schema name. Schema names must have a non-zero length.</value>
  </data>
  <data name="EntityMappingConfiguration_InvalidTableSharing" xml:space="preserve">
    <value>The entity types '{0}' and '{1}' cannot share table '{2}' because they are not in the same type hierarchy or do not have a valid one to one foreign key relationship with matching primary keys between them.</value>
  </data>
  <data name="EntityMappingConfiguration_DuplicateMapInheritedProperties" xml:space="preserve">
    <value>Properties for type '{0}' can only be mapped once. Ensure the MapInheritedProperties method is only used during one call to the Map method.</value>
  </data>
  <data name="ModelBuilder_ProviderNameNotFound" xml:space="preserve">
    <value>Unable to determine the provider name for connection of type '{0}'.</value>
  </data>
  <data name="TableNotFound" xml:space="preserve">
    <value>The specified table '{0}' was not found in the model. Ensure that the table name has been correctly specified.</value>
  </data>
  <data name="MaxLengthAttribute_InvalidMaxLength" xml:space="preserve">
    <value>The MaxLengthAttribute on property '{0}' on type '{1} is not valid. The Length value must be greater than zero. Use MaxLength() without parameters to indicate that the string or array can have the maximum allowable length.</value>
  </data>
  <data name="NavigationPropertyNotFound" xml:space="preserve">
    <value>The navigation property '{0}' is not a declared property on type '{1}'. Verify that it has not been explicitly excluded from the model and that it is a valid navigation property.</value>
  </data>
  <data name="InvalidTableMapping" xml:space="preserve">
    <value>The type '{0}' has already been mapped to table '{1}'. Specify all mapping aspects of a table in a single Map call.</value>
  </data>
  <data name="KeyRegisteredOnDerivedType" xml:space="preserve">
    <value>A key is registered for the derived type '{0}'. Keys can only be registered for the root type '{1}'.</value>
  </data>
  <data name="KeyPropertyNotFound" xml:space="preserve">
    <value>The key component '{0}' is not a declared property on type '{1}'. Verify that it has not been explicitly excluded from the model and that it is a valid primitive property.</value>
  </data>
  <data name="EntityMappingConfiguration_DuplicateMappedProperties" xml:space="preserve">
    <value>Properties for type '{0}' can only be mapped once. Ensure the Properties method is used and that repeated calls specify each non-key property only once.</value>
  </data>
  <data name="EntityMappingConfiguration_CannotMapIgnoredProperty" xml:space="preserve">
    <value>The property '{1}' on type '{0}' cannot be mapped because it has been explicitly excluded from the model.</value>
  </data>
  <data name="InvalidPropertyExpression" xml:space="preserve">
    <value>The expression '{0}' is not a valid property expression. The expression should represent a property: C#: 't =&gt; t.MyProperty'  VB.Net: 'Function(t) t.MyProperty'.</value>
  </data>
  <data name="InversePropertyAttributeConvention_PropertyNotFound" xml:space="preserve">
    <value>The InversePropertyAttribute on property '{2}' on type '{3}' is not valid. The property '{0}' is not a valid navigation property on the related type '{1}'. Ensure that the property exists and is a valid reference or collection navigation property.</value>
  </data>
  <data name="ForeignKeyPropertyNotFound" xml:space="preserve">
    <value>The foreign key component '{0}' is not a declared property on type '{1}'. Verify that it has not been explicitly excluded from the model and that it is a valid primitive property.</value>
  </data>
  <data name="ArgumentPropertyIsNull" xml:space="preserve">
    <value>The argument property '{0}' cannot be null.</value>
  </data>
  <data name="ComplexTypeConfigurationMismatch" xml:space="preserve">
    <value>The type '{0}' has already been configured as an entity type. It cannot be reconfigured as a complex type.</value>
  </data>
  <data name="StringLengthAttributeConvention_InvalidMaximumLength" xml:space="preserve">
    <value>The StringLengthAttribute on property '{0}' on type '{1}' is not valid. The maximum length must be greater than zero. Use MaxLength() without parameters to indicate that the string or array can have the maximum allowable length.</value>
  </data>
  <data name="ForeignKeyAttributeConvention_InvalidNavigationProperty" xml:space="preserve">
    <value>The ForeignKeyAttribute on property '{0}' on type '{1}' is not valid. The navigation property '{2}' was not found on the dependent type '{1}'. The Name value should be a valid navigation property name.</value>
  </data>
  <data name="ConflictingColumnConfiguration" xml:space="preserve">
    <value>Conflicting configuration settings were specified for column '{0}' on table '{1}': {2}</value>
  </data>
  <data name="ModelGeneration_UnableToDetermineKeyOrder" xml:space="preserve">
    <value>Unable to determine composite primary key ordering for type '{0}'. Use the ColumnAttribute or the HasKey method to specify an order for composite primary keys.</value>
  </data>
  <data name="DuplicateEntryInUserDictionary" xml:space="preserve">
    <value>The {0} value '{1}' already exists in the user-defined dictionary.</value>
  </data>
  <data name="ConflictingInferredColumnType" xml:space="preserve">
    <value>Values of incompatible types ('{1}' and '{2}') were assigned to the '{0}' discriminator column. Values of the same type must be specified. To explicitly specify the type of the discriminator column use the HasColumnType method.</value>
  </data>
  <data name="InvalidEntitySplittingProperties" xml:space="preserve">
    <value>Not all properties for type '{0}' have been mapped. Either map those properties or explicitly excluded them from the model.</value>
  </data>
</root>